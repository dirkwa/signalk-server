/**
 * Standard WASM Loader
 *
 * Loads WASI P1 plugins (AssemblyScript and Rust library plugins)
 */

import * as fs from 'fs'
import Debug from 'debug'
import loader from '@assemblyscript/loader'
import { FetchHandler } from 'as-fetch/bindings.raw.esm.js'
import { WasmPluginInstance, WasmCapabilities } from '../types'
import { createEnvImports } from '../bindings/env-imports'
import { updateResourceProviderInstance } from '../bindings/resource-provider'
import { getNodeFetch } from '../utils/fetch-wrapper'

const debug = Debug('signalk:wasm:loader:standard')

// Try to use native Node.js WASI first, fall back to @wasmer/wasi
let WASI: any
try {
  WASI = require('node:wasi').WASI
} catch {
  WASI = require('@wasmer/wasi').WASI
}

/**
 * Load a standard WASI P1 plugin (AssemblyScript or Rust library)
 */
export async function loadStandardPlugin(
  pluginId: string,
  wasmPath: string,
  wasmBuffer: Buffer,
  vfsRoot: string,
  capabilities: WasmCapabilities,
  app?: any
): Promise<WasmPluginInstance> {
  debug(`Loading standard WASM plugin: ${pluginId} from ${wasmPath}`)

  // Create WASI instance with VFS isolation
  debug(`Creating WASI instance for ${pluginId}`)
  const wasi = new WASI({
    version: 'preview1',
    env: { PLUGIN_ID: pluginId },
    args: [],
    preopens: { '/': vfsRoot }
  })
  debug(`WASI instance created`)

  // Compile WASM module
  debug(`Compiling WASM module for inspection...`)
  let module: WebAssembly.Module
  try {
    module = await WebAssembly.compile(wasmBuffer as BufferSource)
    debug(`WASM module compiled successfully`)
  } catch (compileError) {
    debug(`WASM compilation failed: ${compileError}`)
    throw compileError
  }

  // Inspect module to determine plugin type
  const imports = WebAssembly.Module.imports(module)
  const moduleExports = WebAssembly.Module.exports(module)
  debug(`Module has ${imports.length} imports, ${moduleExports.length} exports`)
  debug(`Module imports: ${JSON.stringify(imports.map(i => `${i.module}.${i.name}`).slice(0, 20))}`)

  // Detect plugin type
  const hasPluginId = moduleExports.some(e => e.name === 'plugin_id')
  const hasAllocate = moduleExports.some(e => e.name === 'allocate')
  const hasStart = moduleExports.some(e => e.name === '_start')

  const isRustLibraryPlugin = hasPluginId && hasAllocate
  const isRustPlugin = hasStart
  const isAssemblyScriptPlugin = hasPluginId && !hasAllocate && !hasStart

  debug(`Plugin type detection: AS=${isAssemblyScriptPlugin}, RustLib=${isRustLibraryPlugin}, RustCmd=${isRustPlugin}`)

  // Get WASI imports
  const wasiImports = (wasi.getImportObject ? wasi.getImportObject() : wasi.getImports(module)) as any
  debug(`Got WASI imports`)

  // Refs that will be populated after instantiation
  const memoryRef: { current: WebAssembly.Memory | null } = { current: null }
  const rawExportsRef: { current: any } = { current: null }
  const asLoaderRef: { current: any } = { current: null }

  // Create environment imports
  const envImports = createEnvImports({
    pluginId,
    capabilities,
    app,
    memoryRef,
    rawExports: rawExportsRef,
    asLoaderInstance: asLoaderRef
  })

  // Initialize as-fetch handler for network capability
  let fetchHandler: any = null
  let fetchImports = {}

  if (capabilities.network) {
    debug(`Setting up as-fetch handler for network capability`)
    const nodeFetch = getNodeFetch()

    // Create a wrapper that reads strings from WASM memory
    const fetchWrapper = async (urlPtr: number | string | URL | RequestInfo, init?: RequestInit) => {
      let url: string

      if (typeof urlPtr === 'number') {
        if (!memoryRef.current) {
          throw new Error('WASM memory not available for string conversion')
        }

        // Read AssemblyScript string from memory (UTF-16LE)
        const SIZE_OFFSET = -4
        const memView = new Uint32Array(memoryRef.current.buffer)
        const strLengthInBytes = memView[(urlPtr + SIZE_OFFSET) >>> 2]
        const strLengthInChars = strLengthInBytes >>> 1
        const strView = new Uint16Array(memoryRef.current.buffer, urlPtr, strLengthInChars)
        url = String.fromCharCode(...Array.from(strView))
        debug(`Converted WASM string pointer ${urlPtr} to URL: ${url}`)
      } else {
        url = String(urlPtr)
      }

      return nodeFetch(url, init)
    }

    fetchHandler = new FetchHandler(fetchWrapper)
    fetchImports = fetchHandler.imports
  }

  // Instantiate the module
  let instance: WebAssembly.Instance
  let asLoaderInstance: any = null
  let rawExports: any

  if (isAssemblyScriptPlugin) {
    debug(`Using AssemblyScript loader for ${pluginId}`)

    asLoaderInstance = await loader.instantiate(module, {
      wasi_snapshot_preview1: wasiImports.wasi_snapshot_preview1 || wasiImports,
      env: envImports,
      ...fetchImports
    })

    instance = asLoaderInstance.instance
    rawExports = asLoaderInstance.exports
    asLoaderRef.current = asLoaderInstance
    debug(`AssemblyScript instance created with loader`)
  } else {
    // Standard WebAssembly instantiation for Rust plugins
    instance = await WebAssembly.instantiate(module, {
      wasi_snapshot_preview1: wasiImports.wasi_snapshot_preview1 || wasiImports,
      env: envImports,
      ...fetchImports
    } as any)
    rawExports = instance.exports as any
    debug(`Standard WASM instance created`)
  }

  // Set refs for use in callbacks
  rawExportsRef.current = rawExports
  if (rawExports.memory) {
    memoryRef.current = rawExports.memory as WebAssembly.Memory
  }

  // Store reference for Asyncify resume
  let asyncifyResumeFunction: (() => any) | null = null

  // Initialize as-fetch handler
  if (fetchHandler && capabilities.network) {
    debug(`Initializing as-fetch handler with exports`)
    fetchHandler.init(rawExports, () => {
      debug(`FetchHandler calling main function to resume execution`)
      if (asyncifyResumeFunction) {
        asyncifyResumeFunction()
      }
    })
  }

  // Initialize based on plugin type
  if (isRustPlugin) {
    debug(`Initializing Rust command plugin: ${pluginId}`)
    wasi.start(instance)
  } else if (isRustLibraryPlugin) {
    debug(`Initialized Rust library plugin: ${pluginId}`)
    if (rawExports._initialize) {
      debug(`Calling _initialize for Rust library plugin`)
      rawExports._initialize()
    }
  } else if (isAssemblyScriptPlugin) {
    debug(`Initialized AssemblyScript plugin: ${pluginId}`)
  } else {
    throw new Error(`Unknown WASM plugin format for ${pluginId}`)
  }

  // Create normalized export interface
  const exports = createPluginExports(
    isAssemblyScriptPlugin,
    isRustLibraryPlugin,
    asLoaderInstance,
    rawExports,
    asyncifyResumeFunction,
    (fn) => { asyncifyResumeFunction = fn }
  )

  const pluginInstance: WasmPluginInstance = {
    pluginId,
    wasmPath,
    vfsRoot,
    capabilities,
    format: 'wasi-p1',
    wasi,
    module,
    instance,
    exports,
    asLoader: asLoaderInstance
  }

  // Update resource provider references
  updateResourceProviderInstance(pluginId, pluginInstance)

  debug(`Successfully loaded WASM plugin: ${pluginId}`)
  return pluginInstance
}

/**
 * Create normalized plugin exports based on plugin type
 */
function createPluginExports(
  isAssemblyScriptPlugin: boolean,
  isRustLibraryPlugin: boolean,
  asLoaderInstance: any,
  rawExports: any,
  asyncifyResumeFunction: (() => any) | null,
  setAsyncifyResume: (fn: (() => any) | null) => void
) {
  let idFunc: () => string
  let nameFunc: () => string
  let schemaFunc: () => string
  let startFunc: (config: string) => number | Promise<number>
  let stopFunc: () => number

  if (isAssemblyScriptPlugin && asLoaderInstance) {
    idFunc = () => {
      const ptr = asLoaderInstance.exports.plugin_id()
      return asLoaderInstance.exports.__getString(ptr)
    }
    nameFunc = () => {
      const ptr = asLoaderInstance.exports.plugin_name()
      return asLoaderInstance.exports.__getString(ptr)
    }
    schemaFunc = () => {
      const ptr = asLoaderInstance.exports.plugin_schema()
      return asLoaderInstance.exports.__getString(ptr)
    }

    startFunc = async (config: string) => {
      debug(`Calling plugin_start with config: ${config.substring(0, 100)}...`)
      const encoder = new TextEncoder()
      const configBytes = encoder.encode(config)
      const configLen = configBytes.length

      const configPtr = asLoaderInstance.exports.__new(configLen, 0)

      const memory = asLoaderInstance.exports.memory.buffer
      const memoryView = new Uint8Array(memory)
      memoryView.set(configBytes, configPtr)

      let resumePromiseResolve: (() => void) | null = null
      const resumePromise = new Promise<void>((resolve) => {
        resumePromiseResolve = resolve
      })

      setAsyncifyResume(() => {
        debug(`Re-calling plugin_start to resume from rewind state`)
        const resumeResult = asLoaderInstance.exports.plugin_start(configPtr, configLen)
        if (resumePromiseResolve) {
          resumePromiseResolve()
        }
        return resumeResult
      })

      let result = asLoaderInstance.exports.plugin_start(configPtr, configLen)

      if (typeof asLoaderInstance.exports.asyncify_get_state === 'function') {
        const state = asLoaderInstance.exports.asyncify_get_state()
        debug(`Asyncify state after plugin_start: ${state}`)

        if (state === 1) {
          debug(`Plugin is in unwound state - waiting for async operation to complete`)
          await resumePromise
          debug(`Async operation completed, plugin execution resumed`)
        } else {
          setAsyncifyResume(null)
        }
      }

      if (typeof asLoaderInstance.exports.__free === 'function') {
        asLoaderInstance.exports.__free(configPtr)
      }

      return result
    }
    stopFunc = () => asLoaderInstance.exports.plugin_stop()
  } else if (isRustLibraryPlugin) {
    debug(`Setting up Rust library plugin exports with buffer-based strings`)

    const callRustStringFunc = (funcName: string): string => {
      const func = rawExports[funcName]
      if (typeof func !== 'function') {
        debug(`Warning: ${funcName} not found in exports`)
        return ''
      }

      const maxLen = 8192
      const allocate = rawExports.allocate
      if (typeof allocate !== 'function') {
        throw new Error('Rust plugin missing allocate export')
      }

      const outPtr = allocate(maxLen)
      if (!outPtr) {
        throw new Error(`Failed to allocate ${maxLen} bytes for ${funcName}`)
      }

      try {
        const writtenLen = func(outPtr, maxLen)
        if (writtenLen <= 0) {
          debug(`${funcName} returned ${writtenLen}`)
          return ''
        }

        const memory = rawExports.memory as WebAssembly.Memory
        const bytes = new Uint8Array(memory.buffer, outPtr, writtenLen)
        const decoder = new TextDecoder('utf-8')
        const result = decoder.decode(bytes)
        debug(`${funcName} returned: ${result.substring(0, 100)}...`)
        return result
      } finally {
        const deallocate = rawExports.deallocate
        if (typeof deallocate === 'function') {
          deallocate(outPtr, maxLen)
        }
      }
    }

    idFunc = () => callRustStringFunc('plugin_id')
    nameFunc = () => callRustStringFunc('plugin_name')
    schemaFunc = () => callRustStringFunc('plugin_schema')

    startFunc = (config: string) => {
      debug(`Calling Rust plugin_start with config: ${config.substring(0, 100)}...`)

      const encoder = new TextEncoder()
      const configBytes = encoder.encode(config)
      const configLen = configBytes.length

      const allocate = rawExports.allocate
      const configPtr = allocate(configLen)

      const memory = rawExports.memory as WebAssembly.Memory
      const memoryView = new Uint8Array(memory.buffer)
      memoryView.set(configBytes, configPtr)

      try {
        const result = rawExports.plugin_start(configPtr, configLen)
        debug(`plugin_start returned: ${result}`)
        return result
      } finally {
        const deallocate = rawExports.deallocate
        if (typeof deallocate === 'function') {
          deallocate(configPtr, configLen)
        }
      }
    }

    stopFunc = () => {
      const result = rawExports.plugin_stop()
      debug(`plugin_stop returned: ${result}`)
      return result
    }
  } else {
    // Rust command plugins or unknown
    idFunc = rawExports.id
    nameFunc = rawExports.name
    schemaFunc = rawExports.schema
    startFunc = rawExports.start
    stopFunc = rawExports.stop
  }

  // Wrap http_endpoints if it exists
  const httpEndpointsFunc = rawExports.http_endpoints
    ? (isAssemblyScriptPlugin && asLoaderInstance
        ? () => {
            const ptr = asLoaderInstance.exports.http_endpoints()
            return asLoaderInstance.exports.__getString(ptr)
          }
        : rawExports.http_endpoints)
    : undefined

  // Wrap poll if it exists (for plugins that need periodic execution)
  const pollFunc = rawExports.poll
    ? (isAssemblyScriptPlugin && asLoaderInstance
        ? () => asLoaderInstance.exports.poll()
        : rawExports.poll)
    : undefined

  return {
    id: idFunc,
    name: nameFunc,
    schema: schemaFunc,
    start: startFunc,
    stop: stopFunc,
    memory: rawExports.memory,
    ...(httpEndpointsFunc && { http_endpoints: httpEndpointsFunc }),
    ...(pollFunc && { poll: pollFunc })
  }
}
